# 拦截器：
掌握Struts2拦截器的配置
## 什么是拦截器：
拦截器其实也是一个类；     
拦截器可以在Action被调用之前和之后执行代码；         
框架的很多核心功能是拦截器实现的；       

## 拦截器特点：
拦截器自由组合，增强了灵活性，扩展性，有利于系统解耦；   
拦截器可以拦截Action请求；            
在访问的Action之前之前和执行之后执行代码实现某项功能；          

### 每个拦截器都有某项功能；
我们可以自由的把某几个拦截器组合在一起使用，也就是说，          
每个拦截器都是可插拔的，你可以选择用与不用，主动权在你手里；使用起来非常的灵活；       
拦截器为系统提供了可扩展性；          
如果要增加新的功能，可以添加新的拦截器，然后和其他拦截器进行合理的组合；       
无需修改之前的程序代码，有利于系统的解耦；             
系统的很多功能由不同的拦截器完成，相互独立，自由组合；           
各个功能像电脑的各个组件一样，变成了可插拔的，而不是把核心功能写死在核心控制器中，不利于系统的变化；       
拦截器可以拦截用户的请求；           
那么拦截器是否可以拦截用户的所有请求？              
注意：不是的；              
拦截器仅拦截对Action的请求；           
也就是说，在访问Action的时候，拦截器才会起作用；            
拦截器会在访问的Action执行之前和执行之后执行代码实现某项功能；                        


### 在哪儿使用拦截器
Struts2的大部分功能都是通过拦截器实现；比如：         
接收输入的参数、数据验证、文件上传、国际化等，都是靠拦截器实现的；        
另外，在我们自己的应用程序中，如果想在Action执行的前后执行特定功能，也可以使用拦截器；          
比如： Action执行时间统计  Action访问权限管理             
Action添加功能，Action的代码不动，使用拦截器实现功能；         
### 为Action添加功能：                 
最容易想到的办法就是在Action中直接写代码，来实现功能；    
现在有了拦截器，就可以，Action的代码不动，为Action提供拦截器，在拦截器中实现这个功能；这样也可以为Action添加功能；      
这个拦截器写好了以后，别的Action如果也想使用这个功能的话，只需要通过配置文件让别的Action使用这个拦截器就行了；    
将来，如果这个Action不想再使用拦截器提供的这个功能了，只要通过配置文件设置这个Action不使用这个拦截器就可以了；很方便；             


## 拦截器的工作方式
拦截器是用来拦截对Action的请求；      
拦截器是在Action执行前后执行；      

#### 拦截器的执行过程是一个递归的过程：
每一个拦截器的执行周期都可以分为三个阶段；   
- 第一个阶段：        
拦截器要执行一些Action执行前的预处理操作；       

- 第二个阶段：   
将控制交给后续拦截器或返回结果字符串；     
执行Action；        
由于可能存在多个拦截器，所以只有最后一个拦截器执行完毕之后，才能执行Action；          
最后一个拦截器之前的其他的拦截器，在第二个阶段，会将控制权交给后续的下一个拦截器，或者将返回的结果码返回给前一个拦截器；            

- 第三个阶段： 
拦截器要执行一些Action执行后的处理操作；       


示例：         
有两个拦截器，分别为：拦截器1和拦截器2；           
当请求Action的时候，会首先执行拦截器1，那么在执行拦截器1的时候，首先执行第一阶段的操作；执行一些Action执行前的预处理操作；              
然后，将控制权交给第二个拦截器，拦截器2；            
拦截器2同样也会首先执行其第一阶段的操作，做一些Action执行前的预处理操作；     
因为拦截器2已经是最后一个拦截器了；所以此时，就会执行Action；        
Action执行完毕之后，要返回一个结果码；           
该结果码就会逆向的首先传给拦截器2，拦截器2再执行其第三阶段的操作，做一些Action执行后的处理操作；执行了第三阶段之后，再将结果码返回给拦截器1；从而，控制权就转给了拦截器1；          
拦截器1也执行了该拦截器定义的Action执行后的处理操作；从而完成了第三阶段执行的任务；      
拦截器1三个阶段执行完成之后，就会根据Struts配置文件中<action>配置的结果向用户呈现相应的视图；                     


### 自带拦截器
Struts2提供了很多的自带拦截器，首先简单的了解几个；  

- params拦截器   
该拦截器负责将请求参数设置为Action的属性；  
在前面接收用户输入数据的时候，有一种方式是使用Action属性来接收用户输入的数据；            
这时就借助了params拦截器；           

- ServletConfig拦截器        
该拦截器将源于ServletAPI的各种对象注入到Action中；           

- fileUpload拦截器      
该拦截器对文件上传提供支持；         

- modelDriven拦截器     
如果Action实现了ModelDriven接口，这个拦截器可以将getModel()返回的结果压入到值栈中；    
然后，用户就可以从值栈中获取其数据；       

- validation拦截器    
将调用Struts2验证框架进行数据验证；     

- workflow拦截器   
将调用Action类的`validate()`方法，来执行编码验证；       
      
这两个拦截器都用来实现数据验证的功能；              
我们使用Struts2的数据验证功能时，就会用到这两个拦截器；               

至于其他的拦截器，可以查看Struts的文档，或是查看对应的源码来了解学习其他拦截器的功能；        



## 拦截器栈
什么是拦截器栈         
拦截器栈就是多个拦截器的组合；它们组合在一起，就成为了一个功能更加强大的拦截器；        
所以说，从结构上看，拦截器栈相当于多个拦截器的组合；          
从功能上看，拦截器栈也是拦截器；            

在Struts2中进行拦截器配置时，是不区分两者的，均视为拦截器；       
其实，拦截器和拦截器栈的关系，非常像过滤器和过滤器链的关系；      
拦截器与过滤器的原理很相似；           



### 默认拦截器
需要掌握两点： 

第一：     
在`struts-default.xml`文件中，定义了一个defaultStack拦截器栈，并将其指定为默认的拦截器；      
`struts-default.xml`文件，位于Struts2的核心jar包中；           
在该文件中，首先，通过<interceptors>标签来定义自带拦截器；           
在这里，我们就可以看到自带拦截器所对应的拦截器类的名字；          
然后，通过<interceptor-stack>标签来定义了一个拦截器栈；名称为 defaultStack；        
其中，包括多个拦截器；            
最后，通过<default-interceptor-ref>标签指定默认的拦截器，就是defaultStack；           

第二：      
该默认拦截器不会被自动的应用；        
只要我们在定义包的过程中，继承了`struts-default`包；那么，defaultStack才会作为默认的拦截器；          
这就是之前，在`struts.xml`文件中定义包的时候，要继承 `struts-default` 的原因了；       
之前的Action都没有配置拦截器，那么这些Action就使用默认的拦截器defaultStack；          


### 配置拦截器
在`Struts.xml`文件中，在定义包的过程中继承 `struts-default`包；       
那么，defaultStack拦截器将作为默认的拦截器；      
这个默认的拦截器还可以改变；                

如何在`struts.xml`文件中配置拦截器，并改变默认的拦截器；           
首先，定义一个包，继承 `"struts-default"`，并在其中添加 <interceptors>标签；在该标签内配置拦截器；然后，通过 <interceptor>标签来定义拦截器；其name属性用来指明拦截器的名称，class属性用来指明拦截器类的完整路径名称；     
还可以通过 <interceptor-stack>标签来定义一个拦截器栈；       
在其内部通过子标签 <interceptor-ref>标签，来指定该拦截器栈所包括的拦截器的名称；       
可以包括多个 <interceptor-ref>标签，从而指定多个拦截器；          
注意：在通过该标签引用拦截器的时候，不仅可以引用拦截器，还可以引用一个拦截器栈；      
在这里，将一个拦截器栈也视为一个拦截器；             
也就是，一个拦截器栈中，还可以包括一个或多个拦截器栈；             
在定义了以上拦截内容以后，还可以通过 <default-interceptor-ref>标签来指定新的默认拦截器；         
最后，在定义action的时候，可以通过 <interceptor-ref>标签，来指定该Action的拦截器；       
如果不指定将使用新的默认拦截器；             
如果要使用原来的默认拦截器，就需要手动的通过 <interceptor-ref>标签来指定了；         

```xml
<package name="packName" extends="struts-default" >
  <interceptors>
      <!--定义拦截器-->
      <interceptor name="interceptorName" class="interceptorClass" />
      <!--定义拦截器栈-->
      <interceptor-stack name="interceptorStackName">
           <!--指定引用的拦截器-->
	   <interceptor-ref name="interceptorName || interceptorStackName" />
      </interceptor-stack>
   <interceptors>
   <!--定义默认的拦截器引用-->
   <default-interceptor-ref name="interceptorName || interceptorStackName" />
   <action name="actionName" class="actionClass">
   <!--为Action指定拦截器引用-->
	<interceptor-ref name="interceptorName || interceptorStackName" />
        <!--省略其他配置-->
   </action>
</package>
```


### 小经验：

第一：       
当拦截器栈中有多个拦截器 <interceptor-ref> 的时候，是按照先后顺序起作用的；     
也就是说，谁写在前，谁先起作用；        

第二：        
拦截器起作用的顺序(先<action>，再本包，再父包) :           
当<action>配置中有拦截器的引用的时候，那么Action就会使用这里的配置的拦截器；        
如果<action>配置中没有引用拦截器的话，那就会在本包中查找有没有默认的拦截器；           
如果有，就使用这个默认拦截器；            
如果本包中也没有配置默认拦截器的话，就会到父包中查找默认的拦截器；          
如果有，就使用父包的默认拦截器；            


#### 拦截器示例：
统计Action的执行时间  
在这个例子中，我们先在Action执行之前获取开始时间；            
然后再执行Action；  
执行完毕后获取结束时间；再通过计算得到执行的时间；           

在这个例子中，我们需要通过继承AbstractInterceptor实现拦截器类；       
并重写`intercept()`方法完成拦截器的功能；            


ActionInvasion类型 ：代表Action的当前执行状态；               


#### 自定义拦截器
Struts2提供了三种开发自定义拦截器的方法，依次进行说明；  
开发自定义拦截器的方法：       

第一种：        
实现interceptor接口；          
该接口中定义了三个方法；      
```
void init() :  用于初始化拦截器所需要的资源；
void destroy() : 用于释放在init()中分配的资源； 与init()方法的作用相反；
String intercept(ActionInvocation ai) throws Exception : 实现拦截器功能；
```

该方法具有一个ActionInvocation类型的参数；           
ActionInvocation对象代表了Action执行的当前的状态；             
通过调用该实例的相应方法，就可以获取Action的上下文，获取Servlet的API等等；             

第二种：            
继承AbstractInterceptor抽象类；           
该抽象类部分实现了interceptor接口；                
它提供了 `init()` 和 `destroy()` 方法的空实现，这样一来，        
在自定义拦截器的时候只需要实现 `intercept() `方法就可以。         
当然，如果用户需要用 `init()` 方法初始化资源或者在 `destroy()` 方法中释放资源的话，就需要对这两个方法进行覆盖；      

第三种：      
继承 MethodFilterInterceptor类；      
该类的功能比较强大；      
可以用来指定拦截器可以拦截哪些方法；         
还可以指定拦截器对哪些方法不进行拦截；        

一般情况下，推荐使用第二种方法来实现；          
当然，如果希望拦截器只拦截部分Action的方法的时候，就需要使用第三种方法了；           


### 小结：
自定义拦截器的开发步骤       
首先，继承AbstractInterceptor实现拦截器类；     
然后，需要在 `struts.xml` 中定义拦截器；       
```
  <interceptor name="..." class="..." />
```
最后，在<action>中引用拦截器；      
 
引用拦截器的时候，可以单独引用；              
就是分别引用自定义拦截器和默认拦截器；              
也可以把需要引用的拦截器配置成拦截器栈，然后引用这个拦截器栈；          

单独引用：引用自定义和默认拦截器        
拦截器栈引用：定义拦截器栈包含自定义和默认拦截器       


#### 拦截器与过滤器的比较
两者既有相似点也有不同点；     
##### 相似点：       

第一点：         
功能相似；           
无论是拦截器还是过滤器，都可以在请求资源之前，执行相应的预处理操作；而在请求的资源执行之后，执行其后续处理操作；

第二点：         
原理相同；         
多个拦截器可以组成拦截器栈；         
在请求的Action执行之前，请求依次经过各个拦截器，执行其相应的附加操作；               
在请求的Action执行完毕之后，按照相反的顺序依次将控制权交给相应的拦截器，来执行其后续的操作；            
多个过滤器也可以组成一个过滤器链；                       
在请求的资源执行之前，请求也要经过各个过滤器，依次执行其中所定义的操作；              
在请求的资源执行完毕之后，同样按照相反的方向再经过相应的过滤器；            

第三点：         
方法类似           
无论是在过滤器还是在拦截器中都用 `init()`方法来实现资源的初始化并且都具有 `destroy()`方法来释放其所占用的资源； 


##### 不同点：
第一：            
拦截的内容不同；   
拦截器只能用于拦截对Action的请求；        
过滤器几乎可以过滤所有的请求；        

第二点：       
在拦截器中可以获取Action的当前执行状态；           
其`intercept()`方法中的参数就存放了Action的当前的执行状态；       
过滤器，则不可以获取Action当前的执行状态；             

第三点：         
过滤器是Servlet中的概念；它的配置是在 `web.xml`文件中进行的；        
拦截器是 `Struts2/Webwork` 中的概念；它是在 `struts.xml`文件中进行配置的；        


### 总结                

什么是拦截器           

拦截器的执行顺序              

拦截器的配置       
```
 定义拦截器 <interceptor>
 拦截器栈   <interceptor-stack>
 引用拦截器 <interceptor-ref>
 默认拦截器配置  <default-interceptor-ref>
```
自定义拦截器   
 
过滤器和拦截器的区别       


