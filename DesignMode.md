## 设计模式是软件开发人员对代码设计经验的总结；
它为我们在实际工作中遇到的一些常见问题提供了完善的解决方案。   
它是一种程序设计的思想。          
但是在学习设计模式之前，我们要掌握面向对象的设计原则。这是设计模式的基础。也可以说设计模式都是遵循面向对象设计原则的；    
然后我们需要掌握设计模式的概念，并且掌握几种常用的设计模式，并且要达到使用这几种常用的设计模式解决实际问题的目的。         
### 面向对象的三个特性：
封装、继承、多态。     
要想开发出好的面向对象的程序，仅仅知道面向对象的特性是不够的，还需要掌握面向对象的设计原则，并能够灵活的运用。       
这些设计原则是面向对象程序设计的基础，在掌握了面向对象的设计原则之后，还要学习设计模式，设计模式是前辈们搞程序设计思想的结晶。         


### 面向对象设计原则
面向对象设计原则简介： 
要学习设计模式，我们首先要掌握面向对象设计原则，面向对象设计原则有哪些呢？        
面向对象设计原则有7个，这7个原则是我们能够开发出一个好的面向对象的程序的重要保障，所以要成为一个优秀的程序设计人员，这7个原则是我们在进行面向对象程序设计时必须要遵守的原则。              
### 面向对象设计原则的7个原则：      
- 第一个原则：             
单一职责原则(SRP)              
它要求每个对象应该只有一种责任。    

- 第二个原则    
开闭原则(OCP)        
开闭原则也就是设计程序时对功能扩展开放，对修改关闭。        

- 第三个原则     
里氏替换原则(LSP)        
它说的是在任何情况下子类替换父类，都不会影响程序的运行          

- 第四个原则   
依赖倒置原则(DIP)          
提倡高层不依赖底层，二者都依赖抽象     

- 第五个原则  
接口隔离原则(ISP)      
把多个功能分开声明，不强迫客户实现不需要的功能。               

- 第六个原则       
迪米特原则(LOP)          
也叫最少知识原则，尽可能的降低访问级别。              

- 第七个原则      
组合/聚合复用原则(CARP)           
它强调尽量不用继承达到复用类的目的，而是使用组合/聚合的方式          

#### 单一职责原则(SRP)
定义：           
系统中的每一个类都应该只有一个职责             
单一职责原则就是我们在设计程序的时候，每个对象要设计为只有一个职责，也就是说我们让每一个对象或是类只做一件事情。而且能够引起这个类或对象发生变化的原因应该只有一个；                  
那么遵守单一职责原则有什么好处呢？     
遵守单一职责原则的好处：             
高内聚，低耦合                        
所谓高内聚是指一个类或功能模块由相关性很强的代码组成，类或模块很难再拆分。它只负责一项任务。          
耦合指的是类之间或模块之间的相互联系；                 
耦合度越高，说明联系越紧密，独立性越差，我们拆分越难。       
相反，耦合度越低，联系越松散，独立性越好，可重用的可能性越大；           
所以说，按照单一职责原则进行开发，可以缩小单个类的规模，降低耦合度，并提高类的复用性；           
如果我们设计程序时让一个类具有多个职责，是不利于代码复用的；                
举例：         
法师，战士都具有攻击类和防御类，攻击类不同，分别为法师，战士设计不同的攻击类，防御类相同，设计为同一个防御类即可，而不是把每个角色的攻击以及防御功能都写在同一个类中，这样就要分别为法师和战士设计一个具有自己的攻击功能和防御功能的类；            


####  开闭原则(OCP)
定义：对扩展开放，对修改关闭          
这个原则主要是针对以前程序员在设计程序时没有考虑到程序的功能也许会扩展，也就是在程序开发结束以后，客户又提出新的需求的时候，程序员只能在原有的程序文件中修改代码或者添加代码，这样做的结果就是很容易导致原有的程序功能发生改变，甚至出现错误；                  
那么针对这种情况，人们提出了开闭原则，也就是对扩展开放，对修改关闭。                 
符合开闭原则给我们的程序带来的好处：               

- 第一个好处：     
可以使程序有很好的适应性和灵活性；          
因为增加功能时不需要修改已有代码，所以已有的代码可以在更多的地方使用；要进行扩展也很方便；           

- 第二个好处：         
稳定性和延续性；          
因为避免了不必要的修改；代码变得更稳定；可以长久保持代码的可靠性；      

- 第三个好处：          
可复用性与可维护性           
由于代码的稳定，所以就更适宜复用；进行功能扩展时也不会影响到已有的代码，使得代码的维护更容易；               


#### 里氏替换原则(LSP)
定义：    
在任何父类出现的地方都可以用它的子类来替换，且不影响功能。          
它是对开闭原则的扩展，        
里氏替换原则所表述的就是在一个继承体系中的对象应该具有共同的外在特征；          
里氏替换原则主张我们使用“抽象”和“多态”将设计中的静态结构改为动态结构；即：在任何父类出现的地方可以用它的子类来替换父类，且不影响功能。             
对象的多态性其实就是最好的里氏替换原则的例子。               
我们只要知道使用多态就是在遵守里氏替换原则就可以了。           


#### 依赖倒置原则(DIP)
也叫控制反转；          
定义：               
高层模块不应该依赖底层模块，两者都应该依赖其抽象；       
抽象不应该依赖细节；              
细节应该依赖抽象；             

在结构化程序设计中，高层模块多数要依赖底层模块，这会导致当底层模块发生变化时，高层模块也需要修改；              
那么，在面向对象的程序设计中，我们遵循依赖倒置原则，将高层模块依赖于底层模块这种现象彻底改变了。                
我们将高层模块和底层模块设计成都依赖于接口或抽象类；            
也就是说，我们创建类的时候最好都来自于接口或抽象类。                          
接口负责公共方法的声明，抽象类负责公共方法的实现。            
那么，依赖倒置原则和开闭原则很相似，它们都是为了我们在增加新功能时，           
不去修改原有的程序；              
但是，开闭原则为我们提出了一个要求，对扩展开放，对修改关闭。这也是我们程序设计的目标。           
而依赖倒置原则为我们提出了具体的解决方法；               
在程序设计时面向接口编程，这就是我们为实现程序设计目标使用的手段；                     
那么，遵循依赖倒置原则进行程序设计时，我们高层和底层都依赖于接口；         
那么，当底层发生变化或修改就不会影响到高层，而且也提高了高层模块代码的复用性。同时也降低了代码的耦合度。提高了代码的可读性、可维护性。                
使得应用程序更容易扩展。                  
好处：           
提高程序的稳定性、可维护性、可扩展性。                      


#### 接口隔离原则(ISP)
定义：        
使用多 个专门的接口比使用单一的总接口要好。            

这个原则就是要求我们将功能拆分开来放在不同的接口中；       
如果我们将所有的功能放在一个接口中，那么我们实现这个接口的时候就要实现它里面所有的方法；            
但是，我们将功能拆分开就简单多了；              
我们需要什么功能就实现什么接口；                 
接口隔离原则的好处：                         
我们增加新功能时想实现什么方法就实现什么方法；        
不强迫新功能实现不需要的方法；               


#### 迪米特原则(LOP)
定义：一个对象应当对其他对象尽可能少的了解。      
迪米特原则又叫最少知识原则。            
意思就是一个对象应当对其他对象尽可能少的了解，也尽可能的被更少的对象了解；通俗点说，就是不和陌生人说话。                     
如果两个类不必彼此直接通信，那么这两个类就不应该发生直接的相互作用；             
当其中一个类需要调用另一个类的某个方法时，我们可以通过中介类来实现。                    
符合这个原则给我们的程序带来的好处：              
好处：      

降低耦合           
迪米特原则的目的在于降低类与类之间的耦合；               
因为最大程度的隐藏了实现，也就避免了不必要的引用和调用。从而使耦合度降低。                
由于每个类尽量减少了对其他类的依赖，因此，很容易使得系统的功能模块独立，使得各个类相互间存在尽可能少的依赖关系。               

缺点：          
通信效率降低；产生大量的中介类。          
但是过度的使用迪米特法则，也会造成系统不同模块之间的通信效率降低，使系统的不同模块之间不容易协调等问题。                 
同时，因为迪米特法则要求类与类之间尽量不直接通信，如果类之间需要通信就需要通过第三方转发的方式，这种情况就直接导致了系统中存在大量的中介类；这些类存在的唯一原因是为了传递类与类之间的相互调用关系，这就毫无疑问的影响了系统的允许效率。                
所以所迪米特原则也不能过度的使用。          


#### 组合/聚合复用原则(CARP)
有些地方也叫合成/聚合复用原则                 
定义：       
优先使用组合，使系统更灵活，其次才考虑继承，达到复用的目的；               

要想达到代码复用的目的，首先想到的是继承；               
但是，要注意，在使用继承时，代码耦合度较高，因此应该优先考虑使用组合或聚合实现代码的复用。                    
由于组合或聚合可以将已有的对象纳入到新对象中，使之成为新对象的一部分。因此新的对象可以调用已有对象的功能；         
好处：                    
组合复用所需要的依赖较少；              
组合复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象；                        
这样做有以下几点好处：          
对象组合是通过获得对其他对象的引用而在运行时刻动态定义的，由于组合要求对象具有良好定义的接口；而且，对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；                   
更进一步的说，因为对象的实现是基于接口的，所以实现上存在较少的依赖关系；                           
在这里还要再强调一下：           
并不是继承不重要，而是不要滥用继承；            
当然，组合复用也有缺点，               
最主要的缺点就是通过使用这种复用建造的系统会有较多的对象需要管理；                            


## 常用设计模式
设计模式简介：       
我们已经学习了面向对象编程中的七个设计原则，我们知道每个原则都有它的优点和缺点，但是在什么情况下使用哪些原则呢？                 
这就是接下来要学习的内容“设计模式”。         
我们所说的设计模式是由这四个人总结出来的。              
Erich Gamma （艾里希 戈莫）博士，是设计模式的开创者，Eclipse的总设计师，IBM OTI技术主管，JUnit共同创作者，敏捷开发的创始人。                     
Richard Helm，在墨尔本大学获得计算机博士学位，曾在IBMT.J.Watson担任研究员。现在IBM咨询集团供职。       
Ralph Johnson，康奈尔大学获得计算机博士学位，伊利诺伊大学教授，著有《重构与模式》            
John Vlissides在斯坦福大学获得计算机博士学位，IBM T.J.Watson担任研究员。                   
人们戏称他们为“四人帮”。              
这4个人在1995年合作完成了《设计模式》一书，成为了程序设计、开发的经典之作，设计模式是对面向对象设计原则的诠释和经典应用。           
真正掌握设计模式后，就会深刻领悟设计原则；                 
设计模式可以理解为我们生活中处理问题的解决方案。                          
当我们想让程序具有某种特性时，可以借鉴设计模式；            
设计模式还是一种编程思想，是智慧的结晶；                     
我们前面提到的“四人帮”一共总结出23种设计模式；                 
现在有些书籍对设计模式进行了扩展，也都是基于这23种设计模式而来的；                       
对于这些设计模式，我们不应该滥用，而应该是合理的使用，这样才能发挥它们的最大效力。              

###  设计模式分类
设计模式按照不同的用途被分为三类，这三种设计模式分别是：          
创建型模式、结构型模式、行为型模式。                      

- 创建型模式                   
如何创建对象以及何时创建对象                  

- 结构型模式    
对象该如何组织以及此案有什么样的结构更合理          

- 行为型模式
规定了各个对象应该具备的职责以及对象间的通信模式            

创建型模式在面向对象的系统中解决的问题就是            
如何创建对象以及何时创建对象           
它会努力的让使用对象的代码，不用太多的关注对象的具体实现类型，不用关注创建的细节，而只要了解对象的抽象类型；                 
创建对象的工作由对象的工厂来实现；                      
那么，这就是创建型模式为我们解决的问题；          

#### 结构型模式的作用是：
在面向对象的系统中的对象爱如何组织以及采用什么样的结构更合理，         
这就是结构型模式所要解决的问题。         
合理的使用结构型模式，可以使系统具有更好的灵活性、扩展性和维护性；             

#### 行为型模式
规定了各个对象应该具备的职责以及对象间的通信模式    
它很好的规范了对象间的调用和数据传递方式。           

### 23种设计模式
这三种模式类型都包含哪些具体的设计模式：      

- 创建型模式
创建型模式包含5种设计模式，它们分别是：   
```
工厂方法(FACTORY METHOD)模式
抽象工厂模式
建造(BUILDER)模式
单例模式(SINGLETON)
原型模式(Prototype)
```
- 结构型模式          
结构型模式包含7种设计模式，这七种设计模式分别是：       
```
适配器(Adapter)模式
合成(Composite)模式
装饰(Decorator)模式
代理(Proxy)模式
享元(Flyweight Pattern)模式
门面(Parade)模式
桥梁(Bridge)模式
```

- 行为型模式
行为型模式包含11种设计模式，它们分别是：     
```
策略(Strategy)模式
模版方法(Template Method)模式
观察者(Observer)模式
迭代子(Iterator)模式
责任链模式
命令模式
备忘录模式
状态模式
访问者模式
解释器模式
调停者模式
```
有些书籍中具体设计模式的名称不一样，这是由于原著是英文的，翻译过程中叫法不一样而已；           


### 常用设计模式

- 简单工厂模式      
首先来学习创建型模式中的工厂方法模式；             
工厂方法模式是创建型模式中比较常用的一个设计模式；          
在学习工厂方法模式之前，我们先来学习一下简单工厂模式；          
学习简单工厂模式有助于我们更好的理解工厂方法模式；            
简单工厂模式也叫做静态工厂方法模式；                 
简单工厂模式并不在23种标准设计模式之中，                 
但，简单工厂模式是工厂方法模式的一个特殊的实现。            

简单工厂模式就是由一个工厂类根据传入的参数决定创建出哪一种产品类的实例；                 

我们可以通过一个例子来学习简单工厂模式；      
假如，我们在一个乳品生产公司，这个公司，可以生产鲜奶和酸奶，那么我们就可以使用简单工厂模式来描述生产过程。        
案例：           
使用简单工厂模式实现一个乳品生产公司控制鲜奶和酸奶的生产过程。                       

我们首先设计一个产品接口；          
然后，增加鲜奶和酸奶类实现产品的接口；             
我们在设计产品接口的时候，可以在接口中添加生产产品的工艺和产品的特征两个方法，大家可以看下面的代码：         
```java
public interface Product {
 void craftwork();  //工艺
 void type();       //产品的特征
}
```
那么，这就是产品接口；        
产品接口有两个抽象方法，一个是生产工艺，一个是产品特征；               
然后，我们再来看一下具体的产品类：         
首先是鲜奶类，它实现了产品接口，然后是酸奶类，也实现了产品接口。       
```java
public class Creamery implements Product {

 @Override
 public void craftwork() {
      System.out.println("牛奶+除菌=鲜奶");
 }
 @Override
 public void type() {
    System.out.println("原味浓香！");
  }
}

public class Yoghourt implements Product {

 @Override
 public void craftwork() {
      System.out.println("牛奶+酵母菌+糖=酸奶");
 }
 @Override
 public void type() {
    System.out.println("酸甜可口！");
  }
}
```
接下来，我们要添加一个静态工厂类，由它来生产我们所需要的产品，如下代码：
```java
public class StaticFactory {
/**
*静态工厂方法
*@throws BadException
*/
public static Product factory(String str) throws BadException{
  if(str.equalsIgnoreCase("yoghourt")) {
         System.out.println("生产酸奶");
          return new Yoghourt();
    )else{
      if(str.equalsIgnoreCase("creamery")){
         System.out.println("生产鲜奶");
         return new Creamery();
       }}else{
           throw new BadException("没有该类型产品！");
          }
     }
}
```

在工厂类中有一个静态的工厂方法，它是以产品接口作为方法的返回值类型，    
就是我们在学习多态的时候学习过的以父类作为方法返回值类型，并且我们为方法传入了一个String类型的参数；         
我们在方法中来判断传入的参数是鲜奶还是酸奶；         
在这里我们进行比较的时候，使用的是不区分大小写的比较方法；         
如果我们判断传入的参数既不是鲜奶也不是酸奶，那么，我们抛出一个我们自己定义的异常BadException；                


我们通过视频，已经知道了如何创建产品接口，和产品实现类以及静态工厂方法；接下来，我们在客户端生产我们的产品，如下代码：       
```java
public class Test {
  public static void main(String[] args) {
    try {
	Product y = StaticFactory.factory("Yoghourt");
	y.craftwork();
	y.type();
	Product c = StaticFactory.factory("Creammery");
	c.craftwork();
	c.type();
     } catch (BadException e) {
	//TODO Auto-generated catch block
	e.printStackTrace();
     }
  }
}
```

我们在main方法中首先生产了一个酸奶类型的产品；      
大家在学习多态的时候知道，我们可以用子类类型的对象来实例化一个父类类型的引用变量；           
在这里，父类就是产品接口；那么，子类就是酸奶类和鲜奶类；                 
然后我们就可以调用子类中重写父类的方法，生产工艺和产品特征这两个方法；    
那么，这个就是我们通过简单工厂模式来实现生产产品的过程。                


#### 简单工厂模式：
在简单工厂模式中，我们的工厂类是处于产品类实例化的中心位置；它必须要知道所有的产品，同时也由这个工厂来决定哪一个产品类应当被实例化；                 
这个模式的优点是允许客户端相对独立于产品创建的过程，并且在系统中引入新产品的时候无需修改客户端；               
也就是说，它在我们引用产品的方面是支持“开/闭”原则的，也就是对扩展开放，对修改关闭；       
那么，简单工厂模式的缺点是什么呢？             
##### 简单工厂模式的缺点是：             
对“开/闭”原则的支持不够。   
因为如果有新的产品加入到系统中时，就需要修改工厂类；         
也就是我们在工厂类中还要加一个if判断；         
我们在前面已经说过，简单工厂模式不属于23个标准模式，                      
但是简单工厂模式是工厂方法模式的一个特殊实现。       
既然我们已经知道了简单工厂模式，那么工厂方法模式就好理解了。                 

#### 工厂方法模式：
工厂方法模式是简单工厂模式的进一步抽象和推广；      
由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点；               
首先，在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做；                 
这个核心类则摇身一变成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。       
这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品；           
这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。              


我们可以在简单工厂模式的基础上来实现工厂方法模式；      
首先我们将原有的工厂类删除掉，然后我们创建一个产品工厂接口，在接口中声明一个方法，方法名可以随便取，例如就叫做工厂，然后我们设置方法的返回值类型为产品接口类型；代码如下：                  
```java
public interface ProductFactory {
 Product factory();
}
```
接下来我们来创建两个具体的产品工厂，也就是鲜奶工厂和酸奶工厂，这两个工厂类要实现产品工厂接口，并且分别实现产品工厂接口中的工厂方法，代码如下：    
```java
public class CreameryFactory implements ProductFactory {
  @Override
  public Product factory() {
	System.out.println("生产鲜奶");
	return new Creamery();
     }
}

public class YoghourtFactory implemens ProductFactory {
  @Override
  public Product factory() {
	System.out.println("生产酸奶");
	return new Yoghourt();
     }
}
```
那么现在我们再增加新的产品的时候就不用修改产品工厂接口，而是增加一个具体的产品类，再增加一个生产该产品的工厂就可以了。
这也就是遵守“开/闭”原则的一个具体应用。对扩展开放，对修改关闭。     


#### 工厂方法模式
大家通过视频已经知道了如何创建产品工厂接口，以及如何创建它的实现类，也就是具体的产品工厂类，下面我们来看一下在客户端如何来完成生产产品的过程。也就是如何来调用工厂类实例化一个产品。代码如下：     
```java
public class Test {
 public static void main(String[] args) {
    ProductFactory y = new YoghourtFactory();
     y.factory().production();
     y.factory().type();
    ProductFactory c = new CreameryFactory();
     c.factory().production();
     c.factory().type();
    }
}
```

在main方法中我们首先声明了一个产品工厂接口类型的引用变量y，然后将它实例化为酸奶工厂类型；接下来，我们就可以调用酸奶工厂类中的factory方法也就是工厂方法，来生产产品，也就是实例化一个具体的产品。这样我们就可以调用产品类中的方法了；        
```
工厂方法模式 == 多态性工厂模式
```
工厂方法模式还有一个别名叫做多态性工厂模式，这显然是因为具体工厂类都有共同的接口，或者都有共同的抽象父类；     
如果系统中需要添加一个新的产品。         
那么所需要的就是向系统中加入一个这个产品类以及它所对应的工厂类就可以了。我们没有必要修改客户端。也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。                       
对于增加新产品来说，这个系统完全支持“开/闭”原则。          


我们已经学过了创建型模式中的一个标准设计模式“工厂方法模式”。           
下面我们来看一下结构型模式中比较典型的一个设计模式“代理(Proxy)模式”              

在前面已经介绍了，         
结构型模式是用来处理对象该如何组织，以及采用什么样的结构更合理等问题。那么，代理模式就是一个比较典型的处理对象间关系的设计模式。      
首先我们看一下什么是代理模式；                    

#### 代理(proxy)模式
代理模式是对象的结构模式，代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用；         

通俗的说，所谓的代理就是一个人代表另一个人来完成某件事情。           
也就是一个客户不想或者不能够直接引用一个对象的时候，而代理对象可以在客户端和目标对象之间起到中介的作用。              
代理可以分为许多种类，例如：远程代理、虚拟代理，保护代理、防火墙代理、同步化代理以及智能引用代理等。         
但是这些代理种类，它们所使用的设计模式是相同的。              

下面通过一个案例来学习一下代理模式。                   
案例：         
例如我们在设计程序时需要处理一个客户端请求；       
那么这个处理请求的过程就可以使用代理模式的设计思想。                

我们首先创建一个抽象的主题，当然也可以是一个接口，然后声明一个抽象的请求方法，也就是说我们不去实现它；代码如下：        
```java
public abstract class Subject {
/**
*声明一个抽象的请求方法
*/
  abstract public void request();
}
```
接下来添加一个真实的主题，也就是继承于抽象主题的类，并且实现我们这个请求的方法，代码如下：
```java
public class RealSubject extends Subject {
 @Override
 public void request() {
    System.out.println("实现请求！");
   }
}
```

在这段代码中我们实现了request方法；方法中我们输出一句话；      
然后，我们再增加一个代理主题的类；它同时也要继承于抽象主题Subject。           
并且实现request方法；但是我们在完成请求的过程中可以顺便做一些其他的事情；代码如下：     
```java
public class ProxySubject extends Subject {
 private RealSubject realSubject;

 @Override
 public void request() {
  preRequest();
   if(realSubject ==null) {
	realSubject = new RealSubject();
	}
	realSubject.request();
	postRequest();
	}
/**
*请求前的操作
*/
private void preRequest() {
   System.out.println("请求前的操作！");
   }
/**
*请求后的操作
*/
private void postRequest() {
  System.out.println("请求后的操作！");
   }
}
```

我们在代理主题类中首先声明了一个真实主题的对象，并且我们在request方法中实例化了这个对象；             
但是，我们在完成实例化之前调用了自己定义的一个方法preRequest方法，并且在完成请求之后又调用了另一个自己定义的方法postRequest方法；          
那么，preRequest和postRequest就是我们在完成请求过程中顺便做的事情了。                     
从这段代码中，就可以看出，我们在代理对象中控制了对真实对象的引用。

我们通过视频已经了解了代理对象如何创建，那么我们在客户端如何发送请求呢？也就是我们如何来实例化一个真实请求的对象呢？代码如下：       
```java
public class Test {
 public static void main(String[] args) {
   Subject subject = new ProxySubject();
    subject.request();
   }
}
```
这段代码很简单，我们在客户端直接声明一个抽象主题的引用变量subject，然后将它实例化为代理主题的类型，接下来调用request方法，也就是请求的方法；         
如果我们将subject实例化为真实主题的类型可以吗？               
也就是将ProxySubject换为RealSubject可以吗？                 
如果替换，当然可以。     
但是，替换之后我们就失去了使用代理的意义。         
同时也不能调用在代理主题中完成请求前和完成请求后的其他操作了。             

在前面我们已经学习了创建型模式中的工厂方法模式和结构型模式中的代理模式，接下来我们来学习行为型模式中具有代表性的策略模式(Strategy)。            
首先来回顾一下行为型模式的概念：             
行为型模式规定了各个对象应该具备的职责以及对象间的通信模式，它很好的规范了对象间的调用和数据传递方式；           
那么，策略模式就是其中一个比较具有代表性的设计模式；                      
下面我们来了解一下策略模式：           

#### 策略模式：
策略模式适合于算法经常变化的情况。          
例如我们定义一系列的算法，并分别封装起来，让它们之间可以相互替换；               
算法的变化不会影响到使用算法的客户，算法可以独立于使用它的客户而变化；          
那么，这就是策略模式的设计思想。                      

接下来我们通过一个例子来学习策略模式。         
案例：            
假设有一个购物商城，商城为了吸引顾客推出会员、VIP等制度。制度规定为普通顾客不打折、会员打9折、VIP打8折。使用策略模式来实现商品价格的计算方法。即：我们同一种商品卖给不同的客户价格不一样，也就是我们商品价格的计算方法有三种；当然，我们可以在同一个类中实现这三种商品价格的计算方法，但是如果再增加其他的算法，我们还要修改原有来的程序。这显然是不符合“开/闭”原则的。                   
这个问题我们如果使用策略模式来解决应该是一个号的解决办法，因为策略模式适合于算法经常变化的情况。              

我们使用策略模式，首先要添加一个抽象策略类，代码如下：                  
```java
public abstract class Account {
  //获取实际的商品销售价格
  public abstract floatgetFactPrice(int amount,int price);
}
```

我们在这个类中添加一个抽象方法，并为它传入两个参数，也就是客户所购买商品的数量和单价；然后，我们以此抽象类为父类，创建具体的策略类来计算不同顾客所应交付的金额。          
那么具体的策略类呢？           
代码如下：       
```java
public class CommonAccount extends Account {
 //普通顾客商品价格计算方法
 public float getFactPrice(int amount,int price) {
   return amount*price;
   }
}
```

首先是普通顾客商品价格计算类，该类继承于抽象策略类Account，并且实现了计算商品价格的方法，这和我们学习的多态是一样的。  
然后，会员，以及VIP的商品价格计算类与普通顾客的是一样的。只不过计算公式不一样；            
那么，策略模式的精华在什么地方呢？代码如下：          
```java
public class Context {
 //持有的策略类引用
 private Account account;
 //构造方法，实例化策略类引用
 public Context (Account account) {
   this.account = account;
 }
  //调用策略方法
 public float doAccount (int amount,int price) {
   return account.getFactPrice(amount,price);
  }
}
```
这段代码也就是策略模式最重要的地方；大家可以看到这是一个名称为Context的类；这个类没有继承于抽象策略类；       
在这个类中我们首先看到一个Account类型的引用变量，然后我们在构造方法中实例化了这个引用变量；接下来我们定义了一个doAccount方法，在这个方法中我们调用了具体策略类的计算商品价格的方法，那么这种结构就是策略模式的基本结构；          

通过视频的学习，对策略模式的架构已经有了基本的了解，下面我们来看一下，在客户端如何使用策略模式，也就是说，我们商场接收到了用户的订单，例如一个用户要买2个“CD唱片”，那么现在我们已知的信息就是用户的基本信息，例如是普通顾客，会员或者VIP会员等。以及用户要购买的产品名称和数量，然后我们通过产品名称可以获得产品的单价，代码如下：               
```java
public class Test {
 public static void main(String[] args) {
  String name = "CD唱片";
  int price = 50;
  int amount = 2;
  float sum = 0;
  //普通顾客
 Context cont = new Context(new CommonAccount());
 sum = cont.doAccount(amount,price);
 System.out.println("您是普通顾客没有折扣，商品名称："+name+"数量："+amount+"单价："+price+"应付金额："+sum);
  //会员
 cont = new Context(new InsiderAccount());
 sum = cont.doAccount(amount,price);
 System.out.println("您是会员，享受9折优惠，商品名称："+name+"数量："+amount+"单价："+price+"应付金额："+sum);
  //VIP会员
 cont = new Context(new VipAccount());
  sum = cont.doAccount(amount,price);
 System.out.println("您是VIP会员，享受8折优惠，商品名称："+name+"数量："+amount+"单价："+price+"应付金额："+sum);
   }
}
```

我们将商品名称name、单价price、购买数量amount都设置为已知条件；        
如果是普通顾客，我们声明一个Context对象cont；           
实例化时传入普通顾客商品价格计算类的类型，然后我们再调用Context类中的doAccount()方法来计算商品的实际金额；         
那么普通顾客与会员和VIP会员的区别在什么地方呢？          
区别在于我们实例化Context引用变量的过程，也就是不同的顾客实例化时传入的类型不一样；                  
例如我们要获取会员购买2个“CD唱片”的实际金额，那么实例化Context对象的时候就传入会    员商品价格计算类的类型就可以了。               

我们通过视频已经掌握了策略模式的设计思想；   
策略模式主要是将算法进行包装；           
是把使用算法的责任和算法本身分割开，委派给不同的对象管理；       
策略模式通常是把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类；                   
简单的说，就是，准备一组算法，并将每一个算法封装起来，使得它们可以互换；在使用策略模式解决问题的时候，大家要将所有的具体策略类中公有的行为放到抽象策略类中；也就是案例中的Account类中；            
而且这个抽象策略类必须是一个java的抽象类，而不能是接口；              
我们使用策略模式可以避免暴露复杂的、与算法相关的数据结构；                  
也就是说，在客户端程序中是不知道具体算法的；         
在我们的案例中大家也可以看到，在处理顾客订单的程序中是不了解实际的商品价格的计算方法的；              
